<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Donjons & Dragons - Narrateur IA</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; }
    textarea, select, button { width: 100%; margin-top: 10px; font-size: 16px; }
    #chat { margin-top: 20px; padding: 10px; background: #f0f0f0; white-space: pre-wrap; border: 1px solid #ccc; height: 300px; overflow-y: scroll; }
    .user { color: blue; font-weight: bold; }
    .llm { color: green; font-weight: bold; }
    .choice-buttons { display: flex; gap: 10px; margin-top: 10px; }
    .choice-buttons button { flex: 1; }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.4.0/jspdf.umd.min.js"></script>
</head>
<body>
<h1>Donjons & Dragons - Narrateur IA</h1>

<label for="mode">Choisir un mode :</label>
<select id="mode">
  <option value="beginner">D√©butant (sc√®ne unique)</option>
  <option value="scenario">Sc√©nario (pas √† pas)</option>
</select>

<div id="chat"></div>
<textarea id="prompt" rows="3" placeholder="Ex: Michel entre dans une taverne..."></textarea>
<div class="choice-buttons">
  <button onclick="sendPromptWithChoice('solution 1, ')">Choisir la solution 1</button>
  <button onclick="sendPromptWithChoice('solution 2, ')">Choisir la solution 2</button>
  <button onclick="sendPromptWithChoice('solution 3, ')">Choisir la solution 3</button>
</div>
<button onclick="sendPrompt()">Envoyer</button>

<button id="summaryButton" style="position: fixed; bottom: 20px; right: 20px; padding: 10px 20px; font-size: 16px;">R√©sum√©</button>

<script>

  class PromptStrategy {
    buildPrompt(history, userInput) {
      throw new Error("M√©thode non impl√©ment√©e");
    }
  }

  class BeginnerPromptStrategy extends PromptStrategy {
    buildPrompt(_, userInput) {
      return `Tu es un ma√Ætre du jeu Donjons & Dragons. Tu parles fran√ßais. √âcris une sc√®ne compl√®te avec :\n- Description du lieu\n- Personnages pr√©sents\n- R√©actions √† l‚Äôarriv√©e du joueur\n- Dialogues naturels\n- Encha√Ænement des √©v√©nements\n\nUtilise un style narratif riche.\n\nSituation de d√©part : ${userInput}`;
    }
  }

  class ScenarioPromptStrategy extends PromptStrategy {
    buildPrompt(history, _) {
      const base = `Tu es le syst√®me narratif du jeu Ch√¢teau & Cr√©atures fantastiques. Tu aides exclusivement le ma√Ætre du jeu (MJ) en g√©n√©rant des sc√®nes riches, cr√©dibles et immersives. Tu ne t‚Äôadresses jamais aux joueurs, seulement au MJ.

              Tu ne d√©cris jamais les dialogues ou actions des joueurs. Tu invites le MJ √† indiquer ce que les joueurs font ou disent, puis tu r√©agis en cons√©quence.

              Quand cela est pertinent (par exemple pour un PNJ, une r√©action ou un environnement), tu peux proposer plusieurs options, **mais une seule fois par r√©ponse**. Structure ces propositions ainsi :
              - **Solution 1 :** ...
              - **Solution 2 :** ...
              - **Solution 3 :** ...

              Tu ne poses pas de questions ouvertes. Tu proposes, tu sugg√®res, tu enrichis l‚Äôhistoire, toujours en fran√ßais, pour faciliter le travail du MJ sans jamais le remplacer.`;

      const historique = history.map(h =>
        (h.role === 'user' ? "Joueur : " : "MJ : ") + h.content
      ).join("\n");
      return `${base}\n\nHistorique de la partie :\n${historique}\n\nContinue l‚Äôhistoire :`;
    }
  }

  function createPromptStrategy(type) {
    if (type === "beginner") return new BeginnerPromptStrategy();
    if (type === "scenario") return new ScenarioPromptStrategy();
    throw new Error("Type de strat√©gie inconnu");
  }

  class OllamaClient {
    constructor(model = "llama3") {
      this.model = model;
    }
    async generate(promptText) {
      const res = await fetch('http://localhost:11434/api/generate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ model: this.model, prompt: promptText, stream: false })
      });
      if (!res.ok) throw new Error("Erreur r√©seau : " + res.status);
      const data = await res.json();
      return data.response;
    }
  }

  const history = [];
  const chatDiv = document.getElementById('chat');
  const promptInput = document.getElementById('prompt');
  const ollama = new OllamaClient();

  function updateChat() {
    chatDiv.innerHTML = history.map(item =>
      `<div class="${item.role}">${item.role === 'user' ? 'üë§' : 'üé≤'} ${item.content}</div>`
    ).join('\n');
    chatDiv.scrollTop = chatDiv.scrollHeight;
  }

  async function sendPrompt(extraPrefix = '') {
  const rawInput = promptInput.value.trim();
  if (!rawInput) return;

  const userVisibleMessage = rawInput;
  const hiddenMessage = extraPrefix + rawInput;

  const mode = document.getElementById('mode').value;
  const strategy = createPromptStrategy(mode);

  if (mode === "scenario") {
    history.push({ role: 'user', content: hiddenMessage });
  } else {
    history.push({ role: 'user', content: userVisibleMessage });
  }

  const prompt = strategy.buildPrompt(history, hiddenMessage);
  console.log('Prompt envoy√© :', prompt);
  promptInput.value = "";
  updateChat();
  try {
    const response = await ollama.generate(prompt);
    history.push({ role: 'assistant', content: response });
    updateChat();
  } catch (err) {
    history.push({ role: 'assistant', content: "‚ùå Erreur : " + err.message });
    updateChat();
    console.error(err);
  }
}

function sendPromptWithChoice(prefix) {
  sendPrompt(prefix);
}

  promptInput.addEventListener('keydown', function(event) {
    if (event.key === 'Enter') {
      event.preventDefault();
      sendPrompt();
    }
  });


  async function sendSummaryRequest() {
  const summaryPrompt = `R√©sum√© de la session :\n\n${history.map(h =>
          (h.role === 'user' ? "Joueur : " : "MJ : ") + h.content
  ).join("\n")}\n\nFais un r√©sum√© clair et concis de cette session.`;

  try {
    const response = await ollama.generate(summaryPrompt);

    const { jsPDF } = window.jspdf;
    const doc = new jsPDF();

    const pageWidth = doc.internal.pageSize.getWidth();
    const margin = 10;
    const maxWidth = pageWidth - margin * 2;
    const lineHeight = 10;
    let y = 20;

    doc.text("R√©sum√© de la session :", margin, y);
    y += lineHeight;


    const lines = doc.splitTextToSize(response, maxWidth);
    lines.forEach(line => {
      if (y + lineHeight > doc.internal.pageSize.getHeight() - margin) {
        doc.addPage();
        y = margin;
      }
      doc.text(line, margin, y);
      y += lineHeight;
    });

    doc.save("resume_session.pdf");
  } catch (err) {
    console.error("Erreur lors de la g√©n√©ration du r√©sum√© :", err);
  }
}


  document.getElementById('summaryButton').addEventListener('click', sendSummaryRequest);




</script>

</body>
</html>