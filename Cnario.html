<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Donjons & Dragons - Narrateur IA</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; }
    textarea, select, button { width: 100%; margin-top: 10px; font-size: 16px; }
    #chat { margin-top: 20px; padding: 10px; background: #f0f0f0; white-space: pre-wrap; border: 1px solid #ccc; height: 300px; overflow-y: scroll; }
    .user { color: blue; font-weight: bold; }
    .llm { color: green; font-weight: bold; }
    .choice-buttons { display: flex; gap: 10px; margin-top: 10px; }
    .choice-buttons button { flex: 1; }
  </style>
</head>
<body>
<h1>Donjons & Dragons - Narrateur IA</h1>

<label for="mode">Choisir un mode :</label>
<select id="mode">
  <option value="beginner">D√©butant (sc√®ne unique)</option>
  <option value="scenario">Sc√©nario (pas √† pas)</option>
</select>

<div id="chat"></div>
<textarea id="prompt" rows="3" placeholder="Ex: Michel entre dans une taverne..."></textarea>
<div class="choice-buttons">
  <button onclick="sendPromptWithChoice('solution 1, ')">Choisir la solution 1</button>
  <button onclick="sendPromptWithChoice('solution 2, ')">Choisir la solution 2</button>
  <button onclick="sendPromptWithChoice('solution 3, ')">Choisir la solution 3</button>
</div>
<button onclick="sendPrompt()">Envoyer</button>

<script>
  // Strategy Interface
  class PromptStrategy {
    buildPrompt(history, userInput) {
      throw new Error("M√©thode non impl√©ment√©e");
    }
  }

  class BeginnerPromptStrategy extends PromptStrategy {
    buildPrompt(_, userInput) {
      return `Tu es un ma√Ætre du jeu Donjons & Dragons. Tu parles fran√ßais. √âcris une sc√®ne compl√®te avec :\n- Description du lieu\n- Personnages pr√©sents\n- R√©actions √† l‚Äôarriv√©e du joueur\n- Dialogues naturels\n- Encha√Ænement des √©v√©nements\n\nUtilise un style narratif riche.\n\nSituation de d√©part : ${userInput}`;
    }
  }

  class ScenarioPromptStrategy extends PromptStrategy {
    buildPrompt(history, _) {
      const base = `Tu es le syst√®me narratif du jeu Ch√¢teau & Cr√©atures fantastiques. Tu aides exclusivement le ma√Ætre du jeu (MJ) en g√©n√©rant des sc√®nes riches, cr√©dibles et immersives. Tu ne t‚Äôadresses jamais aux joueurs, seulement au MJ.

              Tu ne d√©cris jamais les dialogues ou actions des joueurs. Tu invites le MJ √† indiquer ce que les joueurs font ou disent, puis tu r√©agis en cons√©quence.

              Quand cela est pertinent (par exemple pour un PNJ, une r√©action ou un environnement), tu peux proposer plusieurs options, **mais une seule fois par r√©ponse**. Structure ces propositions ainsi :
              - **Solution 1 :** ...
              - **Solution 2 :** ...
              - **Solution 3 :** ...

              Tu ne poses pas de questions ouvertes. Tu proposes, tu sugg√®res, tu enrichis l‚Äôhistoire, toujours en fran√ßais, pour faciliter le travail du MJ sans jamais le remplacer.`;

      const historique = history.map(h =>
        (h.role === 'user' ? "Joueur : " : "MJ : ") + h.content
      ).join("\n");
      return `${base}\n\nHistorique de la partie :\n${historique}\n\nContinue l‚Äôhistoire :`;
    }
  }

  function createPromptStrategy(type) {
    if (type === "beginner") return new BeginnerPromptStrategy();
    if (type === "scenario") return new ScenarioPromptStrategy();
    throw new Error("Type de strat√©gie inconnu");
  }

  class OllamaClient {
    constructor(model = "llama3") {
      this.model = model;
    }
    async generate(promptText) {
      const res = await fetch('http://localhost:11434/api/generate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ model: this.model, prompt: promptText, stream: false })
      });
      if (!res.ok) throw new Error("Erreur r√©seau : " + res.status);
      const data = await res.json();
      return data.response;
    }
  }

  const history = [];
  const chatDiv = document.getElementById('chat');
  const promptInput = document.getElementById('prompt');
  const ollama = new OllamaClient();

  function updateChat() {
    chatDiv.innerHTML = history.map(item =>
      `<div class="${item.role}">${item.role === 'user' ? 'üë§' : 'üé≤'} ${item.content}</div>`
    ).join('\n');
    chatDiv.scrollTop = chatDiv.scrollHeight;
  }

  async function sendPrompt(extraPrefix = '') {
    const rawInput = promptInput.value.trim();
    if (!rawInput) return;

    const userVisibleMessage = rawInput;
    const hiddenMessage = extraPrefix + rawInput;

    const mode = document.getElementById('mode').value;
    const strategy = createPromptStrategy(mode);

    if (mode === "scenario") {
      // Affiche le message original dans le chat, pas le pr√©fix√©
      history.push({ role: 'user', content: userVisibleMessage });
    }

    const prompt = strategy.buildPrompt(history, hiddenMessage);
    console.log('Prompt envoy√© :', prompt); // Log the prompt for debugging
    promptInput.value = "";
    updateChat();
    try {
      const response = await ollama.generate(prompt);
      history.push({ role: 'assistant', content: response });
      updateChat();
    } catch (err) {
      history.push({ role: 'assistant', content: "‚ùå Erreur : " + err.message });
      updateChat();
      console.error(err);
    }
  }

  function sendPromptWithChoice(prefix) {
    sendPrompt(prefix);
  }

  promptInput.addEventListener('keydown', function(event) {
    if (event.key === 'Enter') {
      event.preventDefault(); // Prevent new line
      sendPrompt(); // Trigger the sendPrompt function
    }
  });
</script>
</body>
</html>